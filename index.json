[{"categories":["LoveIt"],"content":"Hugo - **LoveIt** 使用.","date":"2020-03-06","objectID":"/loveit/","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"#Hugo 主题 LoveIt Hugo - LoveIt 使用. h3,h1 { background : lightgray; } h3:hover { color : red; } ","date":"2020-03-06","objectID":"/loveit/:0:0","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"1.clone主题并更新配置 1.git clone LoveIt到themes/目录 2.修改config.tom配置,将LoveIt/sample的config.tom cp到base目录 3.修改config.tom配置,去掉en对应的配置-否则需要中英文各写一篇 vim themes/LoveIt/exampleSite/content/posts/theme-documentation-basics/index.zh-cn.md ","date":"2020-03-06","objectID":"/loveit/:0:1","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"2.官方文档 打开将LoveIt/sample页面: hugo server –source=exampleSite 依据官方文档配置 官方链接 ","date":"2020-03-06","objectID":"/loveit/:0:2","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"3.其他tips hugo serve --disableFastRender --buildDrafts -e production draft开启,product可以开启comment等 社交链接参考: 图标等放在static下 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. static下 ","date":"2020-03-06","objectID":"/loveit/:0:3","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"4.自定义样式 在 assets/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. ","date":"2020-03-06","objectID":"/loveit/:0:4","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"5.搜索 todo content ","date":"2020-03-06","objectID":"/loveit/:0:5","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"6.内容组织 标签: - {{\u003c admonition note “本地资源引用” \u003e}} {{\u003c /admonition \u003e}} 文档: vim themes/LoveIt/exampleSite/content/posts/theme-documentation-content/index.zh-cn.md 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2020-03-06","objectID":"/loveit/:0:6","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"7.前置参数 官方参考 ","date":"2020-03-06","objectID":"/loveit/:0:7","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"8.摘要,默认提取,可手动设置 \u003c!–more–\u003e ","date":"2020-03-06","objectID":"/loveit/:0:8","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"9.markdown语法扩展 ","date":"2020-03-06","objectID":"/loveit/:0:9","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"10.emoji 😄 ","date":"2020-03-06","objectID":"/loveit/:0:10","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"11.公式 ","date":"2020-03-06","objectID":"/loveit/:0:11","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"12.shortcut shortcut官方 也可以style加入css控制 style link image admonition mermaid echarts bilibili... mapbox ","date":"2020-03-06","objectID":"/loveit/:0:12","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"13.hugo获取资源,比如imag \u003ca href=https://gohugo.io/content-management/image-processing/#image-resources\u003e官网链接\u003c/a\u003eimage res获取位置 \" 官网链接 必须index开头的md才能获取当前目录的文件,否则应该放在全局 /asserts/images/下; 不过前置参数resource.name .image方式不能获取 posts下一个目录:如果有index.md只能有一个生效,父dir也不行 todo 页面资源仅仅可由页面包可以访问， 页面包就是一个根部包含index.md, 或者 _index.md文件的目录。资源仅仅与它们所属的最低层级的页面绑定。对于不包含index.md 的目录不附属任何资源。 参考 比如: ![img](/images/huisu.png) {{ $image := resources.Get \"/images/huisu.png\" }} Lighthouse (image)\" Lighthouse (image) . ├── db │ ├── index2.md ---\u003e如果是index,则当前目录及子目录只能渲染一个html │ ├── libc.jpg │ └── sqlite │ ├── libc.jpg │ ├── sqite2 │ │ └── index.md ---\u003e index.md理论上只应该放在最低层目录,且只有一个md │ ├── x.md │ └── xx.md ├── loveit │ ├── featured-image.jpg │ ├── hugo_image_res.png │ └── index.md └── tpl.md ","date":"2020-03-06","objectID":"/loveit/:0:13","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"14.comment (未备案提示忽略) 1.https://valine.js.org/quickstart.html 注册，然后F.； 会生成appid，key 2.修改 vi themes/next/_config.yml ； 修改valine 开启true，把key加上 3.最后！记得在Leancloud -\u003e 设置 -\u003e 安全中心 -\u003e Web 安全域名 把你的域名加进去(域名按提示配置cname) 4.可设置图像,到valine搜Avtar有详细说明,在评论时指定对应邮箱会自动更新图像 5.valine不需要在域名里添加任何dns信息 Tip: 购买域名后：'Code 403: 访问被API域名白名单拒绝，请检查的安全域名设置. 最后一步，web安全域名加入，录入的api访问提示未备案可以忽略 web安全域名：看浏览器显示的是什么加什么:比如https://www.feng1o.com； 没www不行 ","date":"2020-03-06","objectID":"/loveit/:0:14","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"15.seo 参考 google: https://search.google.com/search-console/sitemaps?resource_id=https%3A%2F%2Ffeng1o.github.io%2F 将一个html放在static下,然后加入sitemap.xml baidu: 同样支持html,和sitemap提交(不可嵌套sitemap的xml，提交最低层的即可) 用的这个：https://feng1o.com/feng1o_domain/sitemap.xml add 使用域名绑定，需要在域名管理和github的仓库设置里加入域名 参考 谷歌加新域名，sitemap 百度因为无法爬取github，顾需要使用vercel 参考 Tip: 使用域名绑定，需要在域名管理和github的仓库设置里加入域名 谷歌加新域名，sitemap 百度因为无法爬取github，顾需要使用vercel 参考 ","date":"2020-03-06","objectID":"/loveit/:0:15","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"16.更新err a.new pc: failed to extract shortcode: template for shortcode \"admonition\" not found --\u003e theme/Loveit下的主题需要重新clone下 b.hugo server #debug c.src doc in branch dev； and gen source in publich and then push to master branch。 ","date":"2020-03-06","objectID":"/loveit/:0:16","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["LoveIt"],"content":"17.记录 a.archetypes/default.md 默认的文章模板, 可定制 b. ","date":"2020-03-06","objectID":"/loveit/:0:17","tags":["LoveIt","主题"],"title":"主题文档 - 使用LoveIt","uri":"/loveit/"},{"categories":["algorithm"],"content":"分类(algorithm) - **算法`回溯`** .","date":"2023-03-04","objectID":"/01.%E5%9B%9E%E6%BA%AF/","tags":["回溯","algorithm"],"title":"01.回溯算法梳理","uri":"/01.%E5%9B%9E%E6%BA%AF/"},{"categories":["algorithm"],"content":"#Algorithm 算法 Algorithm - 回溯 learn. h6,h5,h4,h3,h2,h1 { background : lightgray; } h6,h5,h4,h3,h2,h1:hover { color : red; } summary-backtrack-labuladong \u0026\u0026 回溯细分 id:: fa46fb8b-f417-4457-aae7-bcfacfda375d 递归回溯区别:回溯也用到递归，但是相比递归多了条件剪纸，结束条件等； 而递归就是回调自身，斐波那契数列为例，不存在发现结果不对倒回去的步骤； 回溯比如一个格子里走出去，走不通了回去继续换个路劲，一般要有个状态记录走过的 id:: 9374c530-4426-441e-8048-2362e98c3b7b id:: 63f7088c-681a-4fae-a9f0-3712420bbe3c result = [] def backtrack(路径, 选择列表): if 满足结束条件: // 组合的这all都满足，入口就是空也是 result.add(路径) return for 选择 in 选择列表: // 剪枝: 比如同元素的组合 x\u003estart nums[x]=numx[x-1] 跳过 做选择 backtrack(路径, 选择列表) 撤销选择 id:: 63fc2cd5-d8c2-4e77-8486-b5713111d5bb #+BEGIN_QUERY {:title [:h5.font-bold.blue.opacity-40\"3. query (and BFS (and dalg (not tpl)) )\"] :query (and “回溯” (and “dalg” (not “tpl”)) ) :result-transform (fn [result] (sort-by( fn [h] (get h :db/id 1) ) \u003e result)) :breadcrumb-show? false :collapsed? true } #+END_QUERY leetcode – backtrace [[2023-02-23 Thu]] id:: 62360062-8288-4366-a172-6bcfff419cd2 78.子集 dalghot100 一系列问题-tip-hot100 [[2022-11-30 Wed]] 回溯回溯1 - \u003e\u003cspan class=\"width-55-hide bg-lightgray-del\"\u003e 排列组合子集-汇总 \u003cspan class=\"hide\"\u003edalg\u003c/span\u003e \u003cspan class=\"gray subw9\"\u003e -tip- \u003c/span\u003e\u003c/span\u003e\u003c/a\u003e \u003ca class=\"indent1 subw8 blue width-13-hide \" \u003e😁\u003c/a\u003e\u003ca class=\"indent1 subw8 gray width-18-hide underline DarkOrchid \" \u003e😭汇总\u003c/a\u003e\u003ca class=\"indent1 subw gray width-3-hide underline red \" \u003e0\u003c/a\u003e \u003c/html\u003e n内的k个数组合 组合和排列区别，在for循环处理，排列all，需要识别visited，组合需去重(start顺序去) 子集II 有重复、不可复选的组合、排列问题 x=start; num =nums[x-1]忽略 组合和等于target 有重复、不可复选的组合、排列问题 [[$red]]==组合问题和子集问题等价== 参考此页 电话号码的字幕组合 — 和无重复数字组合一样，从0号开始，扫完进入下一轮，结束就是n到了size 括号生成 括号生成这个理解 — https://leetcode.cn/problems/permutations/ 46.不同元素的全排列 dalg -tip- 回溯和子集比！1 - 47. 有相同元素的全排列 https://leetcode.cn/problems/n-queens/ 5.n皇后问题 dalg -tip- 回溯回溯对比0 ","date":"2023-03-04","objectID":"/01.%E5%9B%9E%E6%BA%AF/:0:0","tags":["回溯","algorithm"],"title":"01.回溯算法梳理","uri":"/01.%E5%9B%9E%E6%BA%AF/"},{"categories":["go"],"content":"分类(go) - **go`知识点`** .","date":"2023-03-03","objectID":"/01.go_interview2/","tags":["go"],"title":"go知识点梳理","uri":"/01.go_interview2/"},{"categories":["go"],"content":" h7, h6,h5,h4,h3,h2,h1 { background : lightgray; } h3:hover { color : red; } map [[2023-02-20 Mon]] # 最主要的数据结构有两种：哈希查找表（Hash table）、搜索树（Search tree） avl或rb树。 Go 语言采用的是链表解决哈希冲突。 1.9.2 map 内存模型 # 【引申1】slice 和 map 分别作为函数参数时有什么区别？ – slice返回的是结构体 map是指针 bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，第九个就会新加通过overflow连起来 每个bucket内部key 和value是分开放的，不是一组一组放 map在扩容的时候，要搬迁部分bucket，可能存在中间状态， 什么时候扩容？ 壮哉因子超过 阈值6.5， overflow的bucket过多 key为什么是无序的？ 扩容后会搬，key位置会变动很大； 还一个每次for 遍历时go也是从一个随机序号开始的 map不是线程安全的、遍历过程删除加都可能有问题 sync.RWMutex 无法对map的key value取地址，即时通过unsafe.pointer拿到，也可能会变了 interface# go的接口有什么特点: 引入了不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可 iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{} iface 内部维护两个指针，tab 指向一个 itab 实体 data指向具体的值 tab 是接口表指针，指向类型信息；data 是数据指针，则指向具体的数据。它们分别被称为动态类型和动态值。而接口值包括动态类型和动态值 # eface 就比较简单了。只维护了一个 _type 字段，表示空接口所承载的具体的实体类型。data 描述了具体的值 编译期自动检测是否实现了接口 # var _ io.Writer = (*myWriter)(nil) var _ io.Writer = myWriter{} // 检查 myWriter 类型是否实现了 io.Writer 接口 类型转换和断言区别 类型转换、类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作 Go接口和c++接口有和异同 # C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数 channel # 不要通过共享内存来通信，而要通过通信来实现内存共享。 这就是 Go 的并发哲学，它依赖 CSP 模型，基于 channel 实现 # 数据结构 # buf 指向底层循环数组(缓冲channel)， sendq recvq 表示被阻塞的goroutine， sendx recvx 发送接收msg相对位置 向channel发送数据过程怎么样的? a.检查接收的channel是否合法、比如nil直接返回fasle，goroutine 挂起 b.对于不阻塞的发送操作，如果 channel 未关闭并且没有多余的缓冲空间 如果channel已close，panic 如果能从等待接收队列 recvq 里出队一个 sudog（代表一个 goroutine），说明此时 channel 是空的，没有元素，所以才会有等待接收者。这时会调用 send 函数将元素直接从发送者的栈拷贝到接收者的栈，关键操作由 sendDirect 函数完成 如果没有命中以上条件的，说明 channel 已经满了，阻塞起来。 这里有一些绑定操作，sudog 通过 g 字段绑定 goroutine，而 goroutine 通过 waiting 绑定 sudog，sudog 还通过 elem 字段绑定待发送元素的地址，以及 c 字段绑定被“坑”在此处的 channel。 所以，待发送的元素地址其实是存储在 sudog 结构体里，也就是当前 goroutine 里。 从channel读取数据怎么样的？ 如果 channel 是一个空值（nil），在非阻塞模式下，会直接返回 和发送函数一样，接下来搞了一个在非阻塞模式下，不用获取锁，快速检测到失败并且返回的操作。 (没准备好: 非缓冲的发送队列里没goroutine，缓冲性buffer是空的 — \u003e 都说明没数据可操作) 接下来的操作，首先会上一把锁，粒度比较大。 接下来，如果有等待发送的队列，说明 channel 已经满了，要么是非缓冲型的 channel，要么是缓冲型的 channel，但 buf 满了。这两种情况下都可以正常接收数据。 最后，取出 sudog 里的 goroutine，调用 goready 将其状态改成 “runnable”，待发送者被唤醒，等待调度器的调度。 关闭goroutine过程 close 逻辑比较简单，对于一个 channel，recvq 和 sendq 中分别保存了阻塞的发送者和接收者。关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接 panic。所以，在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel。 关闭的chan能读取buffer里的数据，因为读取时判定过程是有buffer的无数据并close的才会立即返回 [[2023-02-28 Tue]] 操作channel总结 总结一下，发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。 读、写一个 nil channel 都会被阻塞。 如何优雅关闭channel 有两个不那么优雅地关闭 channel 的方法： 使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。 使用 sync.Once 来保证只关闭一次。 引入一个中间者: channel 通知goroutine关闭，最终有一个主close channel泄露 泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。 另外，程序运行过程中，对于一个 channel，如果没有任何 goroutine 引用了，gc 会对其进行回收操作，不会引起内存泄漏 channel引用有哪些？ # 停止信号 任务定时 # 解耦生产方和消费方 # 控制并发数 # context # GC 1.基础 2. 根对象到底是什么？# 根对象 在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括： 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含指向分配的堆内存区块的指针。 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。 3. 常见的 GC 实现方式有哪些？Go 语言的 GC 使用的是什么？# 算法 其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这两种形式的混合运用, [[追踪式GC]] 特点 Go 的 GC 目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法、 从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC 引用计数式GC 每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC， 快简单、但每次要计算引用数性能差，需要额外内存记录引用数 4. 三色标记法是什么？# 关键 理解对象的三色抽象以及波面(wavefront)推进这两个概念。三色抽象只是一种描述追踪式回收器的方法, 白色:: 要被回收的对象，不可达的 灰色:: 中间带的，可能被回收，也可能可达对象 黑色:: 就是可达的，不可回收的 5. STW 是什么意思？ # 定义:: stop the world，开始gc的时候会停止所有用户代码，导致停止 6. 如何观察 Go GC？# 方式1： GODEBUG=gctrace=1 # 方式2..4: go tool、 runtime.memstate、 gcstate信息 wall clock 是指开始执行到完成所经历的实际时间，包括其他程序和本程序所消耗的时间； cpu time 是指特定程序使用 CPU 的时间 wall clock \u003c cpu time: {{cloze 充分利用多核}} wall clock ≈ cpu time: 未并行执行 wall clock \u003e cpu time: 多核优势不明显 7. 有了 GC，为什么还会发生内存泄露？# 严谨的话来说应该 预期的能很快","date":"2023-03-03","objectID":"/01.go_interview2/:0:0","tags":["go"],"title":"go知识点梳理","uri":"/01.go_interview2/"},{"categories":["go"],"content":" var _ io.Writer = (*myWriter)(nil) var _ io.Writer = myWriter{} // 检查 myWriter 类型是否实现了 io.Writer 接口 ","date":"2023-03-03","objectID":"/01.go_interview2/:0:4","tags":["go"],"title":"go知识点梳理","uri":"/01.go_interview2/"},{"categories":["go"],"content":"xxxxxxxxxxxxxxxxxx weight: 6 title: “go知识点梳理” date: 2023-03-03T19:10:14+08:00 draft: false # true will be not indexed in debug mode lastmod: 2023-03-03T19:10:14+08:00 author: “feng1o” authorLink: “https://feng1o.github.io” description: “分类(go) - go知识点 .” featuredImage: images/go.png # 对应图片 #featuredImagePreview: /featuredImage/excel-featured-image.jpg tags: [“go”] categories: [go] lightgallery: true ","date":"2023-03-03","objectID":"/01.go_interview2/:1:0","tags":["go"],"title":"go知识点梳理","uri":"/01.go_interview2/"},{"categories":["go"],"content":"toc: enable: true auto: true h7, h6,h5,h4,h3,h2,h1 { background : lightgray; } h3:hover { color : red; } map [[2023-02-20 Mon]] # 最主要的数据结构有两种：哈希查找表（Hash table）、搜索树（Search tree） avl或rb树。 Go 语言采用的是链表解决哈希冲突。 1.9.2 map 内存模型 # 【引申1】slice 和 map 分别作为函数参数时有什么区别？ – slice返回的是结构体 map是指针 bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，第九个就会新加通过overflow连起来 每个bucket内部key 和value是分开放的，不是一组一组放 map在扩容的时候，要搬迁部分bucket，可能存在中间状态， 什么时候扩容？ 壮哉因子超过 阈值6.5， overflow的bucket过多 key为什么是无序的？ 扩容后会搬，key位置会变动很大； 还一个每次for 遍历时go也是从一个随机序号开始的 map不是线程安全的、遍历过程删除加都可能有问题 sync.RWMutex 无法对map的key value取地址，即时通过unsafe.pointer拿到，也可能会变了 interface# go的接口有什么特点: 引入了不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可 iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{} iface 内部维护两个指针，tab 指向一个 itab 实体 data指向具体的值 tab 是接口表指针，指向类型信息；data 是数据指针，则指向具体的数据。它们分别被称为动态类型和动态值。而接口值包括动态类型和动态值 # eface 就比较简单了。只维护了一个 _type 字段，表示空接口所承载的具体的实体类型。data 描述了具体的值 编译期自动检测是否实现了接口 # var _ io.Writer = (*myWriter)(nil) var _ io.Writer = myWriter{} // 检查 myWriter 类型是否实现了 io.Writer 接口 类型转换和断言区别 类型转换、类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作 Go接口和c++接口有和异同 # C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数 channel # 不要通过共享内存来通信，而要通过通信来实现内存共享。 这就是 Go 的并发哲学，它依赖 CSP 模型，基于 channel 实现 # 数据结构 # buf 指向底层循环数组(缓冲channel)， sendq recvq 表示被阻塞的goroutine， sendx recvx 发送接收msg相对位置 向channel发送数据过程怎么样的? a.检查接收的channel是否合法、比如nil直接返回fasle，goroutine 挂起 b.对于不阻塞的发送操作，如果 channel 未关闭并且没有多余的缓冲空间 如果channel已close，panic 如果能从等待接收队列 recvq 里出队一个 sudog（代表一个 goroutine），说明此时 channel 是空的，没有元素，所以才会有等待接收者。这时会调用 send 函数将元素直接从发送者的栈拷贝到接收者的栈，关键操作由 sendDirect 函数完成 如果没有命中以上条件的，说明 channel 已经满了，阻塞起来。 这里有一些绑定操作，sudog 通过 g 字段绑定 goroutine，而 goroutine 通过 waiting 绑定 sudog，sudog 还通过 elem 字段绑定待发送元素的地址，以及 c 字段绑定被“坑”在此处的 channel。 所以，待发送的元素地址其实是存储在 sudog 结构体里，也就是当前 goroutine 里。 从channel读取数据怎么样的？ 如果 channel 是一个空值（nil），在非阻塞模式下，会直接返回 和发送函数一样，接下来搞了一个在非阻塞模式下，不用获取锁，快速检测到失败并且返回的操作。 (没准备好: 非缓冲的发送队列里没goroutine，缓冲性buffer是空的 — \u003e 都说明没数据可操作) 接下来的操作，首先会上一把锁，粒度比较大。 接下来，如果有等待发送的队列，说明 channel 已经满了，要么是非缓冲型的 channel，要么是缓冲型的 channel，但 buf 满了。这两种情况下都可以正常接收数据。 最后，取出 sudog 里的 goroutine，调用 goready 将其状态改成 “runnable”，待发送者被唤醒，等待调度器的调度。 关闭goroutine过程 close 逻辑比较简单，对于一个 channel，recvq 和 sendq 中分别保存了阻塞的发送者和接收者。关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接 panic。所以，在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel。 关闭的chan能读取buffer里的数据，因为读取时判定过程是有buffer的无数据并close的才会立即返回 [[2023-02-28 Tue]] 操作channel总结 总结一下，发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。 读、写一个 nil channel 都会被阻塞。 如何优雅关闭channel 有两个不那么优雅地关闭 channel 的方法： 使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。 使用 sync.Once 来保证只关闭一次。 引入一个中间者: channel 通知goroutine关闭，最终有一个主close channel泄露 泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。 另外，程序运行过程中，对于一个 channel，如果没有任何 goroutine 引用了，gc 会对其进行回收操作，不会引起内存泄漏 channel引用有哪些？ # 停止信号 任务定时 # 解耦生产方和消费方 # 控制并发数 # context # GC 1.基础 2. 根对象到底是什么？# 根对象 在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括： 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含指向分配的堆内存区块的指针。 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。 3. 常见的 GC 实现方式有哪些？Go 语言的 GC 使用的是什么？# 算法 其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这两种形式的混合运用, [[追踪式GC]] 特点 Go 的 GC 目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法、 从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC 引用计数式GC 每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC， 快简单、但每次要计算引用数性能差，需要额外内存记录引用数 4. 三色标记法是什么？# 关键 理解对象的三色抽象以及波面(wavefront)推进这两个概念。三色抽象只是一种描述追踪式回收器的方法, 白色:: 要被回收的对象，不可达的 灰色:: 中间带的，可能被回收，也可能可达对象 黑色:: 就是可达的，不可回收的 5. STW 是什么意思？ # 定义:: stop the world，开始gc的时候会停止所有用户代码，导致停止 6. 如何观察 Go GC？# 方式1： GODEBUG=gctrace=1 # 方式2..4: go tool、 runtime.memstate、 gcstate信息 wall clock 是指开始执行到完成所经历的实际时间，包括其他程序和本程序所消耗的时间； cpu time 是指特定程序使用 CPU 的时间 wall clock \u003c cpu time: {{cloze 充分利用多核}} wall clock ≈ cpu time: 未并行执行 wall clock \u003e cpu time: 多核优势不明显 7. 有了 GC，为","date":"2023-03-03","objectID":"/01.go_interview2/:2:0","tags":["go"],"title":"go知识点梳理","uri":"/01.go_interview2/"},{"categories":["go"],"content":" var _ io.Writer = (*myWriter)(nil) var _ io.Writer = myWriter{} // 检查 myWriter 类型是否实现了 io.Writer 接口 ","date":"2023-03-03","objectID":"/01.go_interview2/:2:4","tags":["go"],"title":"go知识点梳理","uri":"/01.go_interview2/"},{"categories":["go"],"content":"xxxxxxxxxxxxxxxxxx weight: 6 title: “go知识点梳理” date: 2023-03-03T19:10:14+08:00 draft: false # true will be not indexed in debug mode lastmod: 2023-03-03T19:10:14+08:00 author: “feng1o” authorLink: “https://feng1o.github.io” description: “分类(go) - go知识点 .” featuredImage: images/go.png # 对应图片 #featuredImagePreview: /featuredImage/excel-featured-image.jpg tags: [“go”] categories: [go] lightgallery: true ","date":"2023-03-03","objectID":"/01.go_interview2/:3:0","tags":["go"],"title":"go知识点梳理","uri":"/01.go_interview2/"},{"categories":["go"],"content":"toc: enable: true auto: true h7, h6,h5,h4,h3,h2,h1 { background : lightgray; } h3:hover { color : red; } map [[2023-02-20 Mon]] # 最主要的数据结构有两种：哈希查找表（Hash table）、搜索树（Search tree） avl或rb树。 Go 语言采用的是链表解决哈希冲突。 1.9.2 map 内存模型 # 【引申1】slice 和 map 分别作为函数参数时有什么区别？ – slice返回的是结构体 map是指针 bmap 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，第九个就会新加通过overflow连起来 每个bucket内部key 和value是分开放的，不是一组一组放 map在扩容的时候，要搬迁部分bucket，可能存在中间状态， 什么时候扩容？ 壮哉因子超过 阈值6.5， overflow的bucket过多 key为什么是无序的？ 扩容后会搬，key位置会变动很大； 还一个每次for 遍历时go也是从一个随机序号开始的 map不是线程安全的、遍历过程删除加都可能有问题 sync.RWMutex 无法对map的key value取地址，即时通过unsafe.pointer拿到，也可能会变了 interface# go的接口有什么特点: 引入了不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可 iface 和 eface 都是 Go 中描述接口的底层结构体，区别在于 iface 描述的接口包含方法，而 eface 则是不包含任何方法的空接口：interface{} iface 内部维护两个指针，tab 指向一个 itab 实体 data指向具体的值 tab 是接口表指针，指向类型信息；data 是数据指针，则指向具体的数据。它们分别被称为动态类型和动态值。而接口值包括动态类型和动态值 # eface 就比较简单了。只维护了一个 _type 字段，表示空接口所承载的具体的实体类型。data 描述了具体的值 编译期自动检测是否实现了接口 # var _ io.Writer = (*myWriter)(nil) var _ io.Writer = myWriter{} // 检查 myWriter 类型是否实现了 io.Writer 接口 类型转换和断言区别 类型转换、类型断言本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作 Go接口和c++接口有和异同 # C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数 channel # 不要通过共享内存来通信，而要通过通信来实现内存共享。 这就是 Go 的并发哲学，它依赖 CSP 模型，基于 channel 实现 # 数据结构 # buf 指向底层循环数组(缓冲channel)， sendq recvq 表示被阻塞的goroutine， sendx recvx 发送接收msg相对位置 向channel发送数据过程怎么样的? a.检查接收的channel是否合法、比如nil直接返回fasle，goroutine 挂起 b.对于不阻塞的发送操作，如果 channel 未关闭并且没有多余的缓冲空间 如果channel已close，panic 如果能从等待接收队列 recvq 里出队一个 sudog（代表一个 goroutine），说明此时 channel 是空的，没有元素，所以才会有等待接收者。这时会调用 send 函数将元素直接从发送者的栈拷贝到接收者的栈，关键操作由 sendDirect 函数完成 如果没有命中以上条件的，说明 channel 已经满了，阻塞起来。 这里有一些绑定操作，sudog 通过 g 字段绑定 goroutine，而 goroutine 通过 waiting 绑定 sudog，sudog 还通过 elem 字段绑定待发送元素的地址，以及 c 字段绑定被“坑”在此处的 channel。 所以，待发送的元素地址其实是存储在 sudog 结构体里，也就是当前 goroutine 里。 从channel读取数据怎么样的？ 如果 channel 是一个空值（nil），在非阻塞模式下，会直接返回 和发送函数一样，接下来搞了一个在非阻塞模式下，不用获取锁，快速检测到失败并且返回的操作。 (没准备好: 非缓冲的发送队列里没goroutine，缓冲性buffer是空的 — \u003e 都说明没数据可操作) 接下来的操作，首先会上一把锁，粒度比较大。 接下来，如果有等待发送的队列，说明 channel 已经满了，要么是非缓冲型的 channel，要么是缓冲型的 channel，但 buf 满了。这两种情况下都可以正常接收数据。 最后，取出 sudog 里的 goroutine，调用 goready 将其状态改成 “runnable”，待发送者被唤醒，等待调度器的调度。 关闭goroutine过程 close 逻辑比较简单，对于一个 channel，recvq 和 sendq 中分别保存了阻塞的发送者和接收者。关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接 panic。所以，在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel。 关闭的chan能读取buffer里的数据，因为读取时判定过程是有buffer的无数据并close的才会立即返回 [[2023-02-28 Tue]] 操作channel总结 总结一下，发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。 读、写一个 nil channel 都会被阻塞。 如何优雅关闭channel 有两个不那么优雅地关闭 channel 的方法： 使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。 使用 sync.Once 来保证只关闭一次。 引入一个中间者: channel 通知goroutine关闭，最终有一个主close channel泄露 泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。 另外，程序运行过程中，对于一个 channel，如果没有任何 goroutine 引用了，gc 会对其进行回收操作，不会引起内存泄漏 channel引用有哪些？ # 停止信号 任务定时 # 解耦生产方和消费方 # 控制并发数 # context # GC 1.基础 2. 根对象到底是什么？# 根对象 在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括： 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含指向分配的堆内存区块的指针。 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。 3. 常见的 GC 实现方式有哪些？Go 语言的 GC 使用的是什么？# 算法 其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这两种形式的混合运用, [[追踪式GC]] 特点 Go 的 GC 目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法、 从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC 引用计数式GC 每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC， 快简单、但每次要计算引用数性能差，需要额外内存记录引用数 4. 三色标记法是什么？# 关键 理解对象的三色抽象以及波面(wavefront)推进这两个概念。三色抽象只是一种描述追踪式回收器的方法, 白色:: 要被回收的对象，不可达的 灰色:: 中间带的，可能被回收，也可能可达对象 黑色:: 就是可达的，不可回收的 5. STW 是什么意思？ # 定义:: stop the world，开始gc的时候会停止所有用户代码，导致停止 6. 如何观察 Go GC？# 方式1： GODEBUG=gctrace=1 # 方式2..4: go tool、 runtime.memstate、 gcstate信息 wall clock 是指开始执行到完成所经历的实际时间，包括其他程序和本程序所消耗的时间； cpu time 是指特定程序使用 CPU 的时间 wall clock \u003c cpu time: {{cloze 充分利用多核}} wall clock ≈ cpu time: 未并行执行 wall clock \u003e cpu time: 多核优势不明显 7. 有了 GC，为","date":"2023-03-03","objectID":"/01.go_interview2/:4:0","tags":["go"],"title":"go知识点梳理","uri":"/01.go_interview2/"},{"categories":["go"],"content":" var _ io.Writer = (*myWriter)(nil) var _ io.Writer = myWriter{} // 检查 myWriter 类型是否实现了 io.Writer 接口 xxxxxxxxxxxxxxxxxx ","date":"2023-03-03","objectID":"/01.go_interview2/:4:4","tags":["go"],"title":"go知识点梳理","uri":"/01.go_interview2/"},{"categories":["brpc"],"content":"rpc(brpc) - **brpc`基础`** .","date":"2022-12-17","objectID":"/01.basic/","tags":["brpc"],"title":"01.brpc基础","uri":"/01.basic/"},{"categories":["brpc"],"content":"1.简介 ","date":"2022-12-17","objectID":"/01.basic/:0:1","tags":["brpc"],"title":"01.brpc基础","uri":"/01.basic/"},{"categories":["brpc"],"content":"2.资料 ","date":"2022-12-17","objectID":"/01.basic/:0:2","tags":["brpc"],"title":"01.brpc基础","uri":"/01.basic/"},{"categories":["brpc"],"content":"3.过程 ","date":"2022-12-17","objectID":"/01.basic/:0:3","tags":["brpc"],"title":"01.brpc基础","uri":"/01.basic/"},{"categories":["linux"],"content":"linux - **libc.so.6: version `GLIBC_2.14' not found** .","date":"2022-03-08","objectID":"/01.glibc/","tags":["linux","glic"],"title":"linux - glic升级","uri":"/01.glibc/"},{"categories":["linux"],"content":"💥谨慎操作. libc.so.6: version `GLIBC_2.14’ not found. pre { white-space: pre-wrap; word-wrap: break-word; align: left; } h3,h1 { background : lightgray; } h3:hover { color : red; } /lib64/libc.so.6: version `GLIBC_2.14' not found strings /lib64/ligc.so.6 | grep GLIBC 可看支持哪些版本 GLIBC_2.10 GLIBC_2.11 GLIBC_2.12 安装gcc-参考： gcc主要依赖有：gmp，MPFR，MPC，手动安装均可。 根据download_prerequisites比较easey 安装 新版glibc：比较简单，网上资料很多参考 之后把glibc.so.6指向新的，或者改LD_LIBRARY_PATH： 比如export LD_LIBRARY_PATH=/usr/local/glibc-2.17/lib:/lib64/:/usr/local/gcc-4.8/lib64 可能报错：比如某些so版本问题，ld问题，甚至各种命令失效 恢复： 此时恢复2.12为例：LD_PRELOAD=\"/lib64/libc.so.6-2.12\" ln -s /lib64/libc-2.12.so /lib64/libc.so.6 恢复到新的 error while loading shared libraries: __vdso_time: invalid mode for dlopen(): Invalid argument 这个是用的ld和glic问题，比如2.17升级为例 echo \"\" \u003e /etc/ld.so.preload LD_LIBRARY_PATH=/usr/local/glibc-2.17/lib:/lib64/:/usr/local/gcc-4.8/lib64:/usr/lib64 /usr/local/glibc-2.17/lib/ld-2.17.so ./a.out 可以执行，但是不能每个都指定ld-2717.so ","date":"2022-03-08","objectID":"/01.glibc/:0:0","tags":["linux","glic"],"title":"linux - glic升级","uri":"/01.glibc/"},{"categories":["linux"],"content":"最终版 – 谨慎操作,风险极大 源🔗：直接升级rpm包 #!/bin/bash cat \u0026lt;\u0026lt;EOF caveat： be careful, this may destroy your linux system， please backup your data first. EOF echo \u0026quot;May damage your system!\u0026quot; read -p \u0026quot;sure to do ?\u0026quot; t sleep 5 # update glibc to 2.17 for CentOS 6 GLIBC=glibc OS=el6 SERVER=https://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6 VERSION=2.17-55 FULL_VERSION=$GLIBC-$VERSION.fc20 X64=x86_64 I386=i386 I636=i686 REPO_32=epel-6-$I386 REPO_64=epel-6-$X64 SERVER_32=$SERVER/$REPO_32/$FULL_VERSION RPM_32=$VERSION.$OS.$I636.rpm SERVER_64=$SERVER/$REPO_64/$FULL_VERSION RPM_64=$VERSION.$OS.$X64.rpm # Packages P_1=$GLIBC P_2=$GLIBC-common P_3=$GLIBC-devel P_4=$GLIBC-headers P_5=$GLIBC-static P_6=$GLIBC-utils P_7=nscd # Required as dependency of glibc-utils sudo yum install --assumeyes gd # 64-bit --nodeps 慎重使用 sudo rpm -Uvh --nodeps --force $SERVER_64/$P_1-$RPM_64 $SERVER_64/$P_2-$RPM_64 $SERVER_64/$P_3-$RPM_64 $SERVER_64/$P_4-$RPM_64 $SERVER_64/$P_5-$RPM_64 $SERVER_64/$P_6-$RPM_64 $SERVER_64/$P_7-$RPM_64 # Print out versions strings /lib64/libc.so.6 | grep GLIBC # 32-bit # sudo rpm -Uvh --force $SERVER_32/$P_1-$RPM_32 $SERVER_32/$P_2-$RPM_32 $SERVER_32/$P_3-$RPM_32 $SERVER_32/$P_4-$RPM_32 $SERVER_32/$P_5-$RPM_32 $SERVER_32/$P_6-$RPM_32 $SERVER_32/$P_7-$RPM_32 以上操作不可逆,且需重启;如重启失败只能重装系统. 经测试可行 ","date":"2022-03-08","objectID":"/01.glibc/:0:1","tags":["linux","glic"],"title":"linux - glic升级","uri":"/01.glibc/"},{"categories":["go"],"content":"go - **gmp** .","date":"2021-06-08","objectID":"/gmp1/","tags":["go","gmp"],"title":"go - GMP调度器","uri":"/gmp1/"},{"categories":["go"],"content":"原文:GMP分析-手撸goroutine pool go - GMP调度器. 学习:GMP分析-手撸goroutine pool 主流的线程模型型分三种: 内核级线程模型 、 用户级线程 模型和 两级线程 模型（也称混合型线程模型），传统的协程库属于用户级线程模型 用户级/线程模型 用户层面多线程，和内核线程N-1关系，内核只知道用户进程，用户层的线程自己调度控制。 原罪：并不能做到真正意义上的并发，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如 I/O 阻塞）而被 CPU 给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的线程自调度是没有 CPU 时钟中断的，从而没有轮转调度），整个进程被挂起 解决：协程库会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该 KSE 上运行，从而避免了内核调度器由于 KSE 阻塞而做上下文切换，这样整个进程也不会被阻塞了 内核级线程模型 线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成 混合线程模型/两级线程模型 用户线程与内核 KSE 是多对多（N : M）的映射模型 即用户调度器实现用户线程到 KSE 的『调度』，内核调度器实现 KSE 到 CPU 上的『调度』 go语言的G-P-M 模型 goroutine 是一个独立的执行单元，OS 线程2M ，goroutine 动态， 初始 2KB，最大可达 1GB，且自己 Go Scheduler调度，还可自动回收 G : 表Goroutine，Goroutine 对应一个 G 结构，G 存储 Goroutine 的运行堆栈、状态以及任务函数，可重用。G 并非执行体，每个 G 需要绑定到 P 才能被调度执行。 P : Processor，表示逻辑处理器， 对 G 来说，P 相当于 CPU 核，G 只有绑定到 P(在 P 的 local runq 中)才能被调度。对 M 来说，P 提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，P 的数量决定了系统内最大可并行的 G 的数量（前提：物理 CPU 核数 \u003e= P 的数量），P 的数量由用户设置的 GOMAXPROCS 决定，但是不论 GOMAXPROCS 设置为多大，P 的数量最大为 256。 M : Machine，OS 线程抽象，代表着真正执行计算的资源，在绑定有效的 P 后，进入 schedule 循环；而 schedule 循环的机制大致是从 Global 队列、P 的 Local 队列以及 wait 队列中获取 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础，M 的数量是不定的，由 Go Runtime 调整，为了防止创建过多 OS 线程导致系统调度不过来，目前默认最大限制为 10000 个 ","date":"2021-06-08","objectID":"/gmp1/:0:0","tags":["go","gmp"],"title":"go - GMP调度器","uri":"/gmp1/"},{"categories":["db"],"content":"db - **sqlite** .","date":"2020-05-06","objectID":"/path/","tags":["db","sqlite"],"title":"db - sqlite资料","uri":"/path/"},{"categories":["db"],"content":"DB- sqlite . h3,h1 { background : lightgray; } h3:hover { color : red; } ","date":"2020-05-06","objectID":"/path/:0:0","tags":["db","sqlite"],"title":"db - sqlite资料","uri":"/path/"},{"categories":["db"],"content":"1.path a.inside sqlite \u003c\u003cSQLite Database System --详细\u003e\u003e b.官方文档，architecture of sqlite；接着再看一下\"Atomic Commit In SQLite\", ","date":"2020-05-06","objectID":"/path/:0:1","tags":["db","sqlite"],"title":"db - sqlite资料","uri":"/path/"},{"categories":["db"],"content":"2.参考资料 知乎参考 ","date":"2020-05-06","objectID":"/path/:0:2","tags":["db","sqlite"],"title":"db - sqlite资料","uri":"/path/"},{"categories":["db"],"content":"3.简单怎么写个db how to build a database ","date":"2020-05-06","objectID":"/path/:0:3","tags":["db","sqlite"],"title":"db - sqlite资料","uri":"/path/"},{"categories":["db"],"content":"4.sqlite代码 fossi使用 fossil Amalgamation是合并到一个cpp文件了 ","date":"2020-05-06","objectID":"/path/:0:4","tags":["db","sqlite"],"title":"db - sqlite资料","uri":"/path/"},{"categories":["db"],"content":"5.Architecture Architecture of SQLite ","date":"2020-05-06","objectID":"/path/:0:5","tags":["db","sqlite"],"title":"db - sqlite资料","uri":"/path/"},{"categories":["docker"],"content":"docker - **docker基础**","date":"2021-08-08","objectID":"/03.docker-volume-new/","tags":["docker"],"title":"docker - 卷和网络","uri":"/03.docker-volume-new/"},{"categories":["docker"],"content":"基础 docker. pre { white-space: pre-wrap; word-wrap: break-word; align: left; } h3,h1 { background : lightgray; } h3:hover { color : red; } ","date":"2021-08-08","objectID":"/03.docker-volume-new/:0:0","tags":["docker"],"title":"docker - 卷和网络","uri":"/03.docker-volume-new/"},{"categories":["docker"],"content":"1.volume是什么 ","date":"2021-08-08","objectID":"/03.docker-volume-new/:0:1","tags":["docker"],"title":"docker - 卷和网络","uri":"/03.docker-volume-new/"},{"categories":["docker"],"content":"2.volume 用途 a.multi docker共享代码 b.changed frequency， so do not want build c.test and delop at the same time ","date":"2021-08-08","objectID":"/03.docker-volume-new/:0:2","tags":["docker"],"title":"docker - 卷和网络","uri":"/03.docker-volume-new/"},{"categories":["docker"],"content":"3.how to config docker run -v $PWD/xxx:/var/xx【：ro/rw可选】 ","date":"2021-08-08","objectID":"/03.docker-volume-new/:0:3","tags":["docker"],"title":"docker - 卷和网络","uri":"/03.docker-volume-new/"},{"categories":["docker"],"content":"1.docker之间网络 a.docker 内部网络 不灵活 b.1.9后 docker networking [v] 不同宿主机 停止 重启 无序关系链接 运行顺序无关 c.docker链接， 通信抽象层 ","date":"2021-08-08","objectID":"/03.docker-volume-new/:0:4","tags":["docker"],"title":"docker - 卷和网络","uri":"/03.docker-volume-new/"},{"categories":["docker"],"content":"2.创建docker networking a.docker network create xx docker run --net=xx --name=bbb。。。 指定网络； 会在/etc/hosts里有配置，会有bbb.xx作为域名 b.docker network inspect xx c.overlay网络支持跨宿主机 d.docker network connect xx contianernamexx e.docker network disconnect xx continerx ","date":"2021-08-08","objectID":"/03.docker-volume-new/:0:5","tags":["docker"],"title":"docker - 卷和网络","uri":"/03.docker-volume-new/"},{"categories":["docker"],"content":"3.docker特权模式 –privileged docker内在跑docker必须","date":"2021-08-08","objectID":"/03.docker-volume-new/:0:6","tags":["docker"],"title":"docker - 卷和网络","uri":"/03.docker-volume-new/"},{"categories":["docker"],"content":"docker - **docker基础**","date":"2021-08-08","objectID":"/02.docker-commit/","tags":["docker"],"title":"docker - 构建","uri":"/02.docker-commit/"},{"categories":["docker"],"content":"基础 docker. pre { white-space: pre-wrap; word-wrap: break-word; align: left; } h3,h1 { background : lightgray; } h3:hover { color : red; } ","date":"2021-08-08","objectID":"/02.docker-commit/:0:0","tags":["docker"],"title":"docker - 构建","uri":"/02.docker-commit/"},{"categories":["docker"],"content":"1.构建 docker commit docker build + dockerfile ","date":"2021-08-08","objectID":"/02.docker-commit/:0:1","tags":["docker"],"title":"docker - 构建","uri":"/02.docker-commit/"},{"categories":["docker"],"content":"2.docker image设置 daocloud比较快 ustc中科大的 ","date":"2021-08-08","objectID":"/02.docker-commit/:0:2","tags":["docker"],"title":"docker - 构建","uri":"/02.docker-commit/"},{"categories":["docker"],"content":"3.docker commit docker commit -m 'comomment' -a 'author' [id] user/reigtname ","date":"2021-08-08","objectID":"/02.docker-commit/:0:3","tags":["docker"],"title":"docker - 构建","uri":"/02.docker-commit/"},{"categories":["docker"],"content":"4.dockerfile docker build -t=\"仓库/镜像名:tag\" . docker build -t=\"仓库/镜像名:tag\" -f 指定dockerfile docker build --no-cache -t=\"仓库/镜像名:tag\" git@github.com:xx/xx的dockerfile # Version: 0.1 FROM ubuntu:14.04 层 MAINTAINER lf \"xx.com\" 层... RUN apt-get update \u0026\u0026 apt-get install -y nginx RUN echo \"hi dockerfile\" \u003e /usr/share/nginx/html/index.html CMD [\"/bin/bash\", \"ls\", \" -l /\"] [运行时执行run是build。cmd只能一条] ENTRYPOINT [\"/usr/bin/nginx\"，\"-g\" \" daemon off;\"] [不会被run的覆盖，和cmd不一样] ENV XX_PAHT /home/xx VOLUME --TODO: USER ADD / COPY LABEL ARG --build-arg x=b 部分预定义args变量 ONBUILD EXPOSE 8082 ","date":"2021-08-08","objectID":"/02.docker-commit/:0:4","tags":["docker"],"title":"docker - 构建","uri":"/02.docker-commit/"},{"categories":["docker"],"content":"5.other cmd docker history id 看build命令 ","date":"2021-08-08","objectID":"/02.docker-commit/:0:5","tags":["docker"],"title":"docker - 构建","uri":"/02.docker-commit/"},{"categories":["docker"],"content":"6.port和宿主机绑定 a.随机选32678 -- 61000 b.指定： -p c.docker ps -l 或 docker port id port d.docker run -P 会把dockerfile里expose的端口对外公开 ","date":"2021-08-08","objectID":"/02.docker-commit/:0:6","tags":["docker"],"title":"docker - 构建","uri":"/02.docker-commit/"},{"categories":["docker"],"content":"7.push docker hub ","date":"2021-08-08","objectID":"/02.docker-commit/:0:7","tags":["docker"],"title":"docker - 构建","uri":"/02.docker-commit/"},{"categories":["docker"],"content":"8.local registry 加tag： docker tag id registryhost:port /name/仓库 ","date":"2021-08-08","objectID":"/02.docker-commit/:0:8","tags":["docker"],"title":"docker - 构建","uri":"/02.docker-commit/"},{"categories":["docker"],"content":"docker - **docker基础**","date":"2021-08-08","objectID":"/01.docker-one/","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"基础 docker. pre { white-space: pre-wrap; word-wrap: break-word; align: left; } h3,h1 { background : lightgray; } h3:hover { color : red; } ","date":"2021-08-08","objectID":"/01.docker-one/:0:0","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"1.docker守护进程 早期版本 docker daemon -H tcp://ip:port -H ... 后期dockerd ","date":"2021-08-08","objectID":"/01.docker-one/:0:1","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"2.第一个容器 docker run --restart=alawys[on-failure:5] --name test -i -t centos /bin/bash docker update --restart=always \u003cCONTAINER ID\u003e docker rename name1 name2 docker create 容器不运行，更细粒度的控制 本地无，docker hub下载镜像 会创建一个新的容器，有自己的net、ip、网桥； 然后进入一个新的bash页 ","date":"2021-08-08","objectID":"/01.docker-one/:0:2","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"3.使用第一个容器 docker ps -a 查看所有容器 a.主机名 hostname cat /etc/hosts b.ip信息 docker 母鸡 ip a docker inspect hostName c.容器里安装软件包 yum install vim d.退出 exit 这个容器还在，回到宿主机后docker ps -a ","date":"2021-08-08","objectID":"/01.docker-one/:0:3","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"4.启动容器 docker start dockername/dockerid ","date":"2021-08-08","objectID":"/01.docker-one/:0:4","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"5.附着到容器 docer attach name/id ","date":"2021-08-08","objectID":"/01.docker-one/:0:5","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"6.守护容器 docker run --name daemon_test -d centos /bin/sh -c \"while true; do echo \"ehllo; sleep 2; done\" 后台运行 docker stop name/id； ","date":"2021-08-08","objectID":"/01.docker-one/:0:6","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"7.docker logs docker logs -tf name docker logs --tail 1 -t name docker logs --tail - -f -t name ","date":"2021-08-08","objectID":"/01.docker-one/:0:7","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"8.docker Log驱动 docker run --log-driver=\"syslog\" ","date":"2021-08-08","objectID":"/01.docker-one/:0:8","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"9.观察 docker inspect --format='{{ .State.Running }}' test1 ``` [22-root@localhost /var/lib/docker]# ll total 4 drwx------. 2 root root 24 Jun 13 00:15 builder drwx------. 4 root root 92 Jun 13 00:15 buildkit drwx------. 4 root root 150 Jun 16 00:07 containers drwx------. 3 root root 22 Jun 13 00:15 image drwxr-x---. 3 root root 19 Jun 13 00:15 network drwx------. 8 root root 4096 Jun 19 23:15 overlay2 drwx------. 4 root root 32 Jun 13 00:15 plugins drwx------. 2 root root 6 Jun 19 23:15 runtimes drwx------. 2 root root 6 Jun 13 00:15 swarm drwx------. 2 root root 6 Jun 19 23:15 tmp drwx------. 2 root root 6 Jun 13 00:15 trust drwx------. 2 root root 25 Jun 13 00:15 volumes [23-root@localhost /var/lib/docker]# cd containers/ [24-root@localhost /var/lib/docker/containers]# ll total 0 drwx------. 4 root root 237 Jun 19 23:15 901ab0e98300cc163901f94214f5ee69c962c685e098cf350db2c2d26c01ec9e drwx------. 4 root root 237 Jun 19 23:15 a6bc5cee2d394136c6f45d5ade6cad44a4a8be4cc851c3534c2a054b5acfbcc5 [25-root@localhost /var/lib/docker/containers ``` ","date":"2021-08-08","objectID":"/01.docker-one/:0:9","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"10.删除 docker rm name / [`sudo docker ps -q -a`] ","date":"2021-08-08","objectID":"/01.docker-one/:0:10","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"11.cmd docker rmi docker images ","date":"2021-08-08","objectID":"/01.docker-one/:0:11","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["docker"],"content":"12.容器内运行进程 docker exec -d name cmd[touch /data/test_exec] [14-root@localhost /var/lib/docker]# cd containers/ [15-root@localhost /var/lib/docker/containers ","date":"2021-08-08","objectID":"/01.docker-one/:0:12","tags":["docker"],"title":"docker - 第一个容器","uri":"/01.docker-one/"},{"categories":["tpl"],"content":"Hugo - **模板** .","date":"2020-03-06","objectID":"/tpl/","tags":["tpl","模板"],"title":"tpl - md模板文件","uri":"/tpl/"},{"categories":["tpl"],"content":"Hugo more- 模板 使用 摘要-description, more的优先级更高. h3,h1 { background : lightgray; } h3:hover { color : red; } ","date":"2020-03-06","objectID":"/tpl/:0:0","tags":["tpl","模板"],"title":"tpl - md模板文件","uri":"/tpl/"},{"categories":["tpl"],"content":"1.clone主题并更新配置 1.markdown ","date":"2020-03-06","objectID":"/tpl/:0:1","tags":["tpl","模板"],"title":"tpl - md模板文件","uri":"/tpl/"},{"categories":["tpl"],"content":"2.link 引用,link 官方链接 ","date":"2020-03-06","objectID":"/tpl/:0:2","tags":["tpl","模板"],"title":"tpl - md模板文件","uri":"/tpl/"},{"categories":["tpl"],"content":"3.内容组织 标签: - {{\u003c admonition note “本地资源引用” \u003e}} {{\u003c /admonition \u003e}} 文档: vim themes/LoveIt/exampleSite/content/posts/theme-documentation-content/index.zh-cn.md 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2020-03-06","objectID":"/tpl/:0:3","tags":["tpl","模板"],"title":"tpl - md模板文件","uri":"/tpl/"},{"categories":["tpl"],"content":"4.emoji 😄 ","date":"2020-03-06","objectID":"/tpl/:0:4","tags":["tpl","模板"],"title":"tpl - md模板文件","uri":"/tpl/"},{"categories":["tpl"],"content":"4.shortcut shortcut官方 也可以style加入css控制 style link image admonition mermaid echarts bilibili... mapbox ","date":"2020-03-06","objectID":"/tpl/:0:5","tags":["tpl","模板"],"title":"tpl - md模板文件","uri":"/tpl/"},{"categories":["tpl"],"content":"13.hugo获取资源,比如imag \u003ca href=https://gohugo.io/content-management/image-processing/#image-resources\u003e官网链接\u003c/a\u003eimage res获取位置 \" 官网链接 必须index开头的md才能获取当前目录的文件,否则应该放在全局 /asserts/images/下; 不过前置参数resource.name .image方式不能获取 ","date":"2020-03-06","objectID":"/tpl/:0:6","tags":["tpl","模板"],"title":"tpl - md模板文件","uri":"/tpl/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/about/"}]